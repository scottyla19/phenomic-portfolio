<!DOCTYPE html><html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/></head><body><div id="PhenomicRoot"><div data-reactroot="" data-reactid="1" data-react-checksum="1664939328"><!-- react-empty: 2 --><header data-reactid="3"><div class="header" data-reactid="4"><div class="header-left" data-reactid="5"><div class="header-icon" data-reactid="6"><img src="/laforest-icon-144.png" data-reactid="7"/></div><h4 class="header-name" data-reactid="8">Scott LaForest</h4><p data-reactid="9">Web Developer</p></div><div class="header-right" data-reactid="10"><div style="display:inline-block;position:relative;" data-reactid="11"><button style="border:10px;box-sizing:border-box;display:inline-block;font-family:Roboto, sans-serif;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);cursor:pointer;text-decoration:none;margin:0;padding:12px;outline:none;font-size:0;font-weight:inherit;position:relative;z-index:1;overflow:visible;transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms;width:48px;height:48px;background:none;-moz-box-sizing:border-box;-webkit-transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms;-moz-transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms;" tabindex="0" type="button" data-reactid="12"><div data-reactid="13"><span class="material-icons md-36" color="#FF5722" font-size="36px" style="color:#FF5722;position:relative;font-size:24px;display:inline-block;user-select:none;transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-webkit-transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms;-moz-transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms;" data-reactid="14">menu</span></div></button><div style="display:none;" data-reactid="15"><!-- react-empty: 16 --><!-- react-empty: 17 --></div></div></div></div></header><div class="main-container" data-reactid="18"><div class="content" data-reactid="19"><article data-reactid="20"><h1 data-reactid="21">You Don&#x27;t Know JS Part 1</h1><h3 data-reactid="22"><!-- react-text: 23 -->Author: <!-- /react-text --><!-- react-text: 24 -->Scott LaForest<!-- /react-text --></h3><div data-reactid="25"><p data-reactid="26"><!-- react-text: 27 -->All examples and notes are taken from the excellent and free to <!-- /react-text --><a href="https://github.com/getify/You-Dont-Know-JS" data-reactid="28">read (online)</a><!-- react-text: 29 --> series of books titled <!-- /react-text --><em data-reactid="30">You Don&#x27;t Know JS</em><!-- react-text: 31 --> by Kyle Simpson.<!-- /react-text --></p><!-- react-text: 32 -->
<!-- /react-text --><h2 id="53117" data-reactid="33"><a href="#53117" class="phenomic-HeadingAnchor" data-reactid="34">#</a><!-- react-text: 35 -->5/31/17<!-- /react-text --></h2><!-- react-text: 36 -->
<!-- /react-text --><p data-reactid="37"><!-- react-text: 38 -->  <!-- /react-text --><strong data-reactid="39">Javascript coercion</strong><!-- react-text: 40 --> and the difference between implicit and explicit coercion when converting or comparing values. Loose equals (<!-- /react-text --><code data-reactid="41">==</code><!-- react-text: 42 -->) implicitly coerces a string value to a number value <!-- /react-text --><code data-reactid="43">&#x27;99.99&#x27; == 99.9</code><!-- react-text: 44 -->. While strict equals (<!-- /react-text --><code data-reactid="45">===</code><!-- react-text: 46 -->) does not convert types, so types must be the same and equal in strict equals.<!-- /react-text --></p><!-- react-text: 47 -->
<!-- /react-text --><p data-reactid="48"><!-- react-text: 49 -->  <!-- /react-text --><strong data-reactid="50">Comments</strong></p><!-- react-text: 51 -->
<!-- /react-text --><ul data-reactid="52"><!-- react-text: 53 -->
<!-- /react-text --><li data-reactid="54"><!-- react-text: 55 -->
<!-- /react-text --><p data-reactid="56">Code without comments is suboptimal.</p><!-- react-text: 57 -->
<!-- /react-text --></li><!-- react-text: 58 -->
<!-- /react-text --><li data-reactid="59"><!-- react-text: 60 -->
<!-- /react-text --><p data-reactid="61">Too many comments (one per line, for example) is probably a sign of poorly written code.</p><!-- react-text: 62 -->
<!-- /react-text --></li><!-- react-text: 63 -->
<!-- /react-text --><li data-reactid="64"><!-- react-text: 65 -->
<!-- /react-text --><p data-reactid="66"><!-- react-text: 67 -->Comments should explain <!-- /react-text --><em data-reactid="68">why</em><!-- react-text: 69 -->, not what. They can optionally explain how if that&#x27;s particularly confusing<!-- /react-text --></p><!-- react-text: 70 -->
<!-- /react-text --><h3 id="scope" data-reactid="71"><a href="#scope" class="phenomic-HeadingAnchor" data-reactid="72">#</a><!-- react-text: 73 -->Scope<!-- /react-text --></h3><!-- react-text: 74 -->
<!-- /react-text --><p data-reactid="75">In JavaScript, each function gets its own scope. Scope is basically a collection of variables as well as the rules for how those variables are accessed by name. Only code inside that function can access that function&#x27;s scoped variables.</p><!-- react-text: 76 -->
<!-- /react-text --><p data-reactid="77"> If one scope is nested inside another, code inside the innermost scope can access variables from either scope.</p><!-- react-text: 78 -->
<!-- /react-text --><h3 id="variables-and-types" data-reactid="79"><a href="#variables-and-types" class="phenomic-HeadingAnchor" data-reactid="80">#</a><!-- react-text: 81 -->Variables and Types<!-- /react-text --></h3><!-- react-text: 82 -->
<!-- /react-text --><p data-reactid="83"> The best and most natural approach is to use arrays for numerically positioned values and use objects for named properties.</p><!-- react-text: 84 -->
<!-- /react-text --><p data-reactid="85"> The specific list of &quot;falsy&quot; values in JavaScript is as follows:</p><!-- react-text: 86 -->
<!-- /react-text --></li><!-- react-text: 87 -->
<!-- /react-text --><li data-reactid="88"><!-- react-text: 89 -->
<!-- /react-text --><p data-reactid="90">&quot;&quot; (empty string)</p><!-- react-text: 91 -->
<!-- /react-text --></li><!-- react-text: 92 -->
<!-- /react-text --><li data-reactid="93"><!-- react-text: 94 -->
<!-- /react-text --><p data-reactid="95">0, -0, NaN (invalid number)</p><!-- react-text: 96 -->
<!-- /react-text --></li><!-- react-text: 97 -->
<!-- /react-text --><li data-reactid="98"><!-- react-text: 99 -->
<!-- /react-text --><p data-reactid="100">null, undefined</p><!-- react-text: 101 -->
<!-- /react-text --></li><!-- react-text: 102 -->
<!-- /react-text --><li data-reactid="103"><!-- react-text: 104 -->
<!-- /react-text --><p data-reactid="105">false</p><!-- react-text: 106 -->
<!-- /react-text --><p data-reactid="107"><strong data-reactid="108">WTF</strong><!-- react-text: 109 -->
For example, arrays are by default coerced to strings by simply joining all the values with commas (,) in between. You might think that two arrays with the same contents would be == equal, but they&#x27;re not:<!-- /react-text --></p><!-- react-text: 110 -->
<!-- /react-text --><pre data-reactid="111"><code class="language-javascript" data-reactid="112">var a = [1,2,3];
var b = [1,2,3];
var c = &quot;1,2,3&quot;;

a == c;     // true
b == c;     // true
a == b;     // false
</code></pre><!-- react-text: 113 -->
<!-- /react-text --></li><!-- react-text: 114 -->
<!-- /react-text --></ul></div></article></div></div><footer data-reactid="115"><div class="footer" data-reactid="116"><div data-reactid="117"><!-- react-text: 118 -->Scott LaForest © <!-- /react-text --><!-- react-text: 119 -->2017<!-- /react-text --></div><div data-reactid="120"><!-- react-text: 121 -->Created with ❤ using  <!-- /react-text --><a href="https://phenomic.io/" style="color:inherit;" data-reactid="122">Phenomic</a></div><div data-reactid="123"><!-- react-text: 124 -->Check out the source code  <!-- /react-text --><a href="https://github.com/scottyla19/phenomic-portfolio" style="color:inherit;" data-reactid="125"><i class="fa fa-github" data-reactid="126"></i></a></div></div></footer></div></div><script id="PhenomicHydration" type="text/json">{"collection=posts&id=2017-05-31":{"status":"idle","node":{"date":"2017-01-01","title":"You Don't Know JS Part 1","desc":"Notes on the first day of reading through You Don't Know JS. Includes coercion, scope, and variables.","tags":"YDKJS","author":"Scott LaForest","posted":"05/31/17","body":{"c":[{"c":["All examples and notes are taken from the excellent and free to ",{"c":"read (online)","p":{"href":"https://github.com/getify/You-Dont-Know-JS"},"t":"a"}," series of books titled ",{"c":"You Don't Know JS","t":"em"}," by Kyle Simpson."],"t":"p"},"\n",{"c":[{"c":"#","p":{"href":"#53117","className":"phenomic-HeadingAnchor"},"t":"a"},"5/31/17"],"p":{"id":"53117"},"t":"h2"},"\n",{"c":["  ",{"c":"Javascript coercion","t":"strong"}," and the difference between implicit and explicit coercion when converting or comparing values. Loose equals (",{"c":"==","t":"code"},") implicitly coerces a string value to a number value ",{"c":"'99.99' == 99.9","t":"code"},". While strict equals (",{"c":"===","t":"code"},") does not convert types, so types must be the same and equal in strict equals."],"t":"p"},"\n",{"c":["  ",{"c":"Comments","t":"strong"}],"t":"p"},"\n",{"c":["\n",{"c":["\n",{"c":"Code without comments is suboptimal.","t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":"Too many comments (one per line, for example) is probably a sign of poorly written code.","t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":["Comments should explain ",{"c":"why","t":"em"},", not what. They can optionally explain how if that's particularly confusing"],"t":"p"},"\n",{"c":[{"c":"#","p":{"href":"#scope","className":"phenomic-HeadingAnchor"},"t":"a"},"Scope"],"p":{"id":"scope"},"t":"h3"},"\n",{"c":"In JavaScript, each function gets its own scope. Scope is basically a collection of variables as well as the rules for how those variables are accessed by name. Only code inside that function can access that function's scoped variables.","t":"p"},"\n",{"c":" If one scope is nested inside another, code inside the innermost scope can access variables from either scope.","t":"p"},"\n",{"c":[{"c":"#","p":{"href":"#variables-and-types","className":"phenomic-HeadingAnchor"},"t":"a"},"Variables and Types"],"p":{"id":"variables-and-types"},"t":"h3"},"\n",{"c":" The best and most natural approach is to use arrays for numerically positioned values and use objects for named properties.","t":"p"},"\n",{"c":" The specific list of \"falsy\" values in JavaScript is as follows:","t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":"\"\" (empty string)","t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":"0, -0, NaN (invalid number)","t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":"null, undefined","t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":"false","t":"p"},"\n",{"c":[{"c":"WTF","t":"strong"},"\nFor example, arrays are by default coerced to strings by simply joining all the values with commas (,) in between. You might think that two arrays with the same contents would be == equal, but they're not:"],"t":"p"},"\n",{"c":{"c":"var a = [1,2,3];\nvar b = [1,2,3];\nvar c = \"1,2,3\";\n\na == c;     // true\nb == c;     // true\na == b;     // false\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n"],"t":"li"},"\n"],"t":"ul"}],"t":"div"}}}}</script><script src="/phenomic.main.js" async=""></script></body></html>