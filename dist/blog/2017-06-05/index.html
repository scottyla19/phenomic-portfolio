<!DOCTYPE html><html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/></head><body><div id="PhenomicRoot"><div data-reactroot="" data-reactid="1" data-react-checksum="-949276714"><!-- react-empty: 2 --><header data-reactid="3"><div class="header" data-reactid="4"><div class="header-left" data-reactid="5"><div class="header-icon" data-reactid="6"><img src="/laforest-icon-144.png" data-reactid="7"/></div><h4 class="header-name" data-reactid="8">Scott LaForest</h4><p data-reactid="9">Web Developer</p></div><div class="header-right" data-reactid="10"><div style="display:inline-block;position:relative;" data-reactid="11"><button style="border:10px;box-sizing:border-box;display:inline-block;font-family:Roboto, sans-serif;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);cursor:pointer;text-decoration:none;margin:0;padding:12px;outline:none;font-size:0;font-weight:inherit;position:relative;z-index:1;overflow:visible;transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms;width:48px;height:48px;background:none;-moz-box-sizing:border-box;-webkit-transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms;-moz-transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms;" tabindex="0" type="button" data-reactid="12"><div data-reactid="13"><span class="material-icons md-36" color="#FF5722" font-size="36px" style="color:#FF5722;position:relative;font-size:24px;display:inline-block;user-select:none;transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-webkit-transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms;-moz-transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms;" data-reactid="14">menu</span></div></button><div style="display:none;" data-reactid="15"><!-- react-empty: 16 --><!-- react-empty: 17 --></div></div></div></div></header><div class="main-container" data-reactid="18"><div class="content" data-reactid="19"><article data-reactid="20"><h1 data-reactid="21">You Don&#x27;t Know JS Part 4</h1><h3 data-reactid="22"><!-- react-text: 23 -->Author: <!-- /react-text --><!-- react-text: 24 -->Scott LaForest<!-- /react-text --></h3><div data-reactid="25"><p data-reactid="26"><!-- react-text: 27 -->All examples and notes are taken from the excellent and free to <!-- /react-text --><a href="https://github.com/getify/You-Dont-Know-JS" data-reactid="28">read (online)</a><!-- react-text: 29 --> series of books titled <!-- /react-text --><em data-reactid="30">You Don&#x27;t Know JS</em><!-- react-text: 31 --> by Kyle Simpson.<!-- /react-text --></p><!-- react-text: 32 -->
<!-- /react-text --><h2 id="6517" data-reactid="33"><a href="#6517" class="phenomic-HeadingAnchor" data-reactid="34">#</a><!-- react-text: 35 -->6/5/17<!-- /react-text --></h2><!-- react-text: 36 -->
<!-- /react-text --><h3 id="scope" data-reactid="37"><a href="#scope" class="phenomic-HeadingAnchor" data-reactid="38">#</a><!-- react-text: 39 -->Scope<!-- /react-text --></h3><!-- react-text: 40 -->
<!-- /react-text --><p data-reactid="41"><em data-reactid="42">use strict mode</em><!-- react-text: 43 --> it seems safer <!-- /react-text --><code data-reactid="44">use strict</code><!-- react-text: 45 --> it avoids the auto creation of a new variable in the global scope.<!-- /react-text --></p><!-- react-text: 46 -->
<!-- /react-text --><p data-reactid="47"><code data-reactid="48">ReferenceError</code><!-- react-text: 49 --> is Scope resolution-failure related, whereas <!-- /react-text --><code data-reactid="50">TypeError</code><!-- react-text: 51 --> implies that Scope resolution was successful, but that there was an illegal/impossible action attempted against the result.<!-- /react-text --></p><!-- react-text: 52 -->
<!-- /react-text --><p data-reactid="53"><strong data-reactid="54">Scope look-up stops once it finds the first match.</strong></p><!-- react-text: 55 -->
<!-- /react-text --><pre data-reactid="56"><code class="language-javascript" data-reactid="57">function foo(a) {
    var b = 2;

    // some code

    function bar() {
        // ...
    }

    // more code

    var c = 3;
}
</code></pre><!-- react-text: 58 -->
<!-- /react-text --><p data-reactid="59"><!-- react-text: 60 -->Because <!-- /react-text --><code data-reactid="61">a</code><!-- react-text: 62 -->, <!-- /react-text --><code data-reactid="63">b</code><!-- react-text: 64 -->, <!-- /react-text --><code data-reactid="65">c</code><!-- react-text: 66 -->, and <!-- /react-text --><code data-reactid="67">bar</code><!-- react-text: 68 --> all belong to the scope bubble of <!-- /react-text --><code data-reactid="69">foo(..)</code><!-- react-text: 70 -->, they are not accessible outside of <!-- /react-text --><code data-reactid="71">foo(..)</code><!-- react-text: 72 -->.<!-- /react-text --></p><!-- react-text: 73 -->
<!-- /react-text --><p data-reactid="74">However, all these identifiers (a, b, c, foo, and bar) are accessible inside of foo(..), and indeed also available inside of bar(..) (assuming there are no shadow identifier declarations inside bar(..)).</p><!-- react-text: 75 -->
<!-- /react-text --><p data-reactid="76"><strong data-reactid="77">Do not use anonymous functions</strong><!-- react-text: 78 --> i.e. <!-- /react-text --><code data-reactid="79">function(){...}</code><!-- react-text: 80 --> instead use:<!-- /react-text --></p><!-- react-text: 81 -->
<!-- /react-text --><p data-reactid="82"><strong data-reactid="83">Inline function expressions</strong><!-- react-text: 84 --> <!-- /react-text --><code data-reactid="85">function name(){...}</code><!-- react-text: 86 -->are powerful and useful -- the question of anonymous vs. named doesn&#x27;t detract from that. Providing a name for your function expression quite effectively addresses all these draw-backs, but has no tangible downsides. The best practice is to always name your function expressions:<!-- /react-text --></p><!-- react-text: 87 -->
<!-- /react-text --><h3 id="let" data-reactid="88"><a href="#let" class="phenomic-HeadingAnchor" data-reactid="89">#</a><!-- react-text: 90 -->let<!-- /react-text --></h3><!-- react-text: 91 -->
<!-- /react-text --><p data-reactid="92">i.e. block scoping like most other languages.</p><!-- react-text: 93 -->
<!-- /react-text --><p data-reactid="94"><!-- react-text: 95 -->The <!-- /react-text --><code data-reactid="96">let</code><!-- react-text: 97 --> keyword attaches the variable declaration to the scope of whatever block (commonly a { .. } pair) it&#x27;s contained in. In other words, <!-- /react-text --><code data-reactid="98">let</code><!-- react-text: 99 --> implicitly hijacks any block&#x27;s scope for its variable declaration.<!-- /react-text --></p></div></article></div></div><footer data-reactid="100"><div class="footer" data-reactid="101"><div data-reactid="102"><!-- react-text: 103 -->Scott LaForest © <!-- /react-text --><!-- react-text: 104 -->2017<!-- /react-text --></div><div data-reactid="105"><!-- react-text: 106 -->Created with ❤ using  <!-- /react-text --><a href="https://phenomic.io/" style="color:inherit;" data-reactid="107">Phenomic</a></div><div data-reactid="108"><!-- react-text: 109 -->Check out the source code  <!-- /react-text --><a href="https://github.com/scottyla19/phenomic-portfolio" style="color:inherit;" data-reactid="110"><i class="fa fa-github" data-reactid="111"></i></a></div></div></footer></div></div><script id="PhenomicHydration" type="text/json">{"collection=posts&id=2017-06-05":{"status":"idle","node":{"date":"2017-01-01","title":"You Don't Know JS Part 4","desc":"Notes on the fourth day of reading through You Don't Know JS. Includes strict mode, scope, and let.","tags":"YDKJS","author":"Scott LaForest","posted":"06/05/17","body":{"c":[{"c":["All examples and notes are taken from the excellent and free to ",{"c":"read (online)","p":{"href":"https://github.com/getify/You-Dont-Know-JS"},"t":"a"}," series of books titled ",{"c":"You Don't Know JS","t":"em"}," by Kyle Simpson."],"t":"p"},"\n",{"c":[{"c":"#","p":{"href":"#6517","className":"phenomic-HeadingAnchor"},"t":"a"},"6/5/17"],"p":{"id":"6517"},"t":"h2"},"\n",{"c":[{"c":"#","p":{"href":"#scope","className":"phenomic-HeadingAnchor"},"t":"a"},"Scope"],"p":{"id":"scope"},"t":"h3"},"\n",{"c":[{"c":"use strict mode","t":"em"}," it seems safer ",{"c":"use strict","t":"code"}," it avoids the auto creation of a new variable in the global scope."],"t":"p"},"\n",{"c":[{"c":"ReferenceError","t":"code"}," is Scope resolution-failure related, whereas ",{"c":"TypeError","t":"code"}," implies that Scope resolution was successful, but that there was an illegal/impossible action attempted against the result."],"t":"p"},"\n",{"c":{"c":"Scope look-up stops once it finds the first match.","t":"strong"},"t":"p"},"\n",{"c":{"c":"function foo(a) {\n    var b = 2;\n\n    // some code\n\n    function bar() {\n        // ...\n    }\n\n    // more code\n\n    var c = 3;\n}\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n",{"c":["Because ",{"c":"a","t":"code"},", ",{"c":"b","t":"code"},", ",{"c":"c","t":"code"},", and ",{"c":"bar","t":"code"}," all belong to the scope bubble of ",{"c":"foo(..)","t":"code"},", they are not accessible outside of ",{"c":"foo(..)","t":"code"},"."],"t":"p"},"\n",{"c":"However, all these identifiers (a, b, c, foo, and bar) are accessible inside of foo(..), and indeed also available inside of bar(..) (assuming there are no shadow identifier declarations inside bar(..)).","t":"p"},"\n",{"c":[{"c":"Do not use anonymous functions","t":"strong"}," i.e. ",{"c":"function(){...}","t":"code"}," instead use:"],"t":"p"},"\n",{"c":[{"c":"Inline function expressions","t":"strong"}," ",{"c":"function name(){...}","t":"code"},"are powerful and useful -- the question of anonymous vs. named doesn't detract from that. Providing a name for your function expression quite effectively addresses all these draw-backs, but has no tangible downsides. The best practice is to always name your function expressions:"],"t":"p"},"\n",{"c":[{"c":"#","p":{"href":"#let","className":"phenomic-HeadingAnchor"},"t":"a"},"let"],"p":{"id":"let"},"t":"h3"},"\n",{"c":"i.e. block scoping like most other languages.","t":"p"},"\n",{"c":["The ",{"c":"let","t":"code"}," keyword attaches the variable declaration to the scope of whatever block (commonly a { .. } pair) it's contained in. In other words, ",{"c":"let","t":"code"}," implicitly hijacks any block's scope for its variable declaration."],"t":"p"}],"t":"div"}}}}</script><script src="/phenomic.main.js" async=""></script></body></html>