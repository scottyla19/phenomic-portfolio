<!DOCTYPE html><html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/></head><body><div id="PhenomicRoot"><div data-reactroot="" data-reactid="1" data-react-checksum="1216184697"><!-- react-empty: 2 --><header data-reactid="3"><div class="header" data-reactid="4"><div class="header-left" data-reactid="5"><div class="header-icon" data-reactid="6"><img src="/laforest-icon-144.png" data-reactid="7"/></div><h4 class="header-name" data-reactid="8">Scott LaForest</h4><p data-reactid="9">Web Developer</p></div><div class="header-right" data-reactid="10"><div style="display:inline-block;position:relative;" data-reactid="11"><button style="border:10px;box-sizing:border-box;display:inline-block;font-family:Roboto, sans-serif;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);cursor:pointer;text-decoration:none;margin:0;padding:12px;outline:none;font-size:0;font-weight:inherit;position:relative;z-index:1;overflow:visible;transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms;width:48px;height:48px;background:none;-moz-box-sizing:border-box;-webkit-transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms;-moz-transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms;" tabindex="0" type="button" data-reactid="12"><div data-reactid="13"><span class="material-icons md-36" color="#FF5722" font-size="36px" style="color:#FF5722;position:relative;font-size:24px;display:inline-block;user-select:none;transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-webkit-transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms;-moz-transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0ms;" data-reactid="14">menu</span></div></button><div style="display:none;" data-reactid="15"><!-- react-empty: 16 --><!-- react-empty: 17 --></div></div></div></div></header><div class="main-container" data-reactid="18"><div class="content" data-reactid="19"><article data-reactid="20"><h1 data-reactid="21">React-Tac-Toe Notes</h1><h3 data-reactid="22"><!-- react-text: 23 -->Author: <!-- /react-text --><!-- react-text: 24 -->Scott LaForest<!-- /react-text --></h3><div data-reactid="25"><h1 id="react-tac-toe-notes" data-reactid="26"><a href="#react-tac-toe-notes" class="phenomic-HeadingAnchor" data-reactid="27">#</a><!-- react-text: 28 -->React-Tac-Toe Notes<!-- /react-text --></h1><!-- react-text: 29 -->
<!-- /react-text --><h2 id="moving-state-upwards" data-reactid="30"><a href="#moving-state-upwards" class="phenomic-HeadingAnchor" data-reactid="31">#</a><!-- react-text: 32 -->Moving State Upwards<!-- /react-text --></h2><!-- react-text: 33 -->
<!-- /react-text --><p data-reactid="34"><!-- react-text: 35 -->It is best to aggregate data from multiple children in the parent. For example move the data and logic from the square =&gt; board =&gt; game component. The parent can then pass the state back down via props. This keeps the state consistent throughout the components.
.
Square no longer keeps its own state; it receives its value from its parent Board and informs its parent when it&#x27;s clicked. We call components like this <!-- /react-text --><strong data-reactid="36">controlled components</strong><!-- react-text: 37 -->.<!-- /react-text --></p><!-- react-text: 38 -->
<!-- /react-text --><h2 id="why-immutability-is-important" data-reactid="39"><a href="#why-immutability-is-important" class="phenomic-HeadingAnchor" data-reactid="40">#</a><!-- react-text: 41 -->Why Immutability Is Important<!-- /react-text --></h2><!-- react-text: 42 -->
<!-- /react-text --><p data-reactid="43">In the previous code example, we suggest using the .slice() operator to copy the squares array prior to making changes and to prevent mutating the existing array. Let&#x27;s talk about what this means and why it is an important concept to learn.</p><!-- react-text: 44 -->
<!-- /react-text --><p data-reactid="45">There are generally two ways for changing data. The first method is to mutate the data by directly changing the values of a variable. The second method is to replace the data with a new copy of the object that also includes desired changes.</p><!-- react-text: 46 -->
<!-- /react-text --><p data-reactid="47">Data change with mutation</p><!-- react-text: 48 -->
<!-- /react-text --><pre data-reactid="49"><code class="language-javascript" data-reactid="50">var player = {score: 1, name: &#x27;Jeff&#x27;};
player.score = 2;
// Now player is {score: 2, name: &#x27;Jeff&#x27;}
</code></pre><!-- react-text: 51 -->
<!-- /react-text --><p data-reactid="52">Data change without mutation</p><!-- react-text: 53 -->
<!-- /react-text --><pre data-reactid="54"><code class="language-javascript" data-reactid="55">var player = {score: 1, name: &#x27;Jeff&#x27;};

var newPlayer = Object.assign({}, player, {score: 2});
// Now player is unchanged, but newPlayer is {score: 2, name: &#x27;Jeff&#x27;}
</code></pre><!-- react-text: 56 -->
<!-- /react-text --><p data-reactid="57">The end result is the same but by not mutating (or changing the underlying data) directly we now have an added benefit that can help us increase component and overall application performance.</p><!-- react-text: 58 -->
<!-- /react-text --><p data-reactid="59"><strong data-reactid="60">Easier Undo/Redo and Time Travel</strong><!-- react-text: 61 -->
Immutability also makes some complex features much easier to implement. Avoiding data mutations lets us keep a reference to older versions of the data, and switch between them if we need to.<!-- /react-text --></p><!-- react-text: 62 -->
<!-- /react-text --><p data-reactid="63"><strong data-reactid="64">Tracking Changes</strong><!-- react-text: 65 -->
Determining if a mutated object has changed is complex because changes are made directly to the object. This then requires comparing the current object to a previous copy, traversing the entire object tree, and comparing each variable and value. This process can become increasingly complex.<!-- /react-text --></p><!-- react-text: 66 -->
<!-- /react-text --><p data-reactid="67">Determining how an immutable object has changed is considerably easier. If the object being referenced is different from before, then the object has changed. That&#x27;s it.</p><!-- react-text: 68 -->
<!-- /react-text --><p data-reactid="69"><strong data-reactid="70">Determining When to Re-render in React</strong><!-- react-text: 71 -->
The biggest benefit of immutability in React comes when you build simple pure components. Since immutable data can more easily determine if changes have been made it also helps to determine when a component requires being re-rendered.<!-- /react-text --></p><!-- react-text: 72 -->
<!-- /react-text --><p data-reactid="73"><!-- react-text: 74 -->We&#x27;ve removed the constructor, and in fact, React supports a simpler syntax called <!-- /react-text --><strong data-reactid="75">functional components for component types like Square that only consist of a render method</strong><!-- react-text: 76 -->.<!-- /react-text --></p><!-- react-text: 77 -->
<!-- /react-text --><h2 id="how-i-bold-ed-the-currently-selected-move" data-reactid="78"><a href="#how-i-bold-ed-the-currently-selected-move" class="phenomic-HeadingAnchor" data-reactid="79">#</a><!-- react-text: 80 -->How I <!-- /react-text --><strong data-reactid="81">bold</strong><!-- react-text: 82 --> ed the currently selected move<!-- /react-text --></h2><!-- react-text: 83 -->
<!-- /react-text --><ol data-reactid="84"><!-- react-text: 85 -->
<!-- /react-text --><li data-reactid="86"><!-- react-text: 87 -->Added a <!-- /react-text --><code data-reactid="88">selectedMove</code><!-- react-text: 89 --> property in <!-- /react-text --><code data-reactid="90">this.state</code><!-- react-text: 91 --> in the constructor<!-- /react-text --></li><!-- react-text: 92 -->
<!-- /react-text --><li data-reactid="93"><!-- react-text: 94 -->Added <!-- /react-text --><code data-reactid="95">selectedMove: history.length</code><!-- react-text: 96 --> in the <!-- /react-text --><code data-reactid="97">handleClick()</code><!-- react-text: 98 --> function to make sure when a new move is added it becomes bold<!-- /react-text --></li><!-- react-text: 99 -->
<!-- /react-text --><li data-reactid="100"><!-- react-text: 101 -->added the following line in the <!-- /react-text --><code data-reactid="102">this.setState({})</code><!-- react-text: 103 -->call in the  <!-- /react-text --><code data-reactid="104">jumpTo(step)</code><!-- react-text: 105 --> function <!-- /react-text --><code data-reactid="106">selectedMove : step</code><!-- react-text: 107 -->;<!-- /react-text --></li><!-- react-text: 108 -->
<!-- /react-text --><li data-reactid="109"><!-- react-text: 110 -->changed the game <!-- /react-text --><code data-reactid="111">render()</code><!-- react-text: 112 --> function to include<!-- /react-text --></li><!-- react-text: 113 -->
<!-- /react-text --></ol><!-- react-text: 114 -->
<!-- /react-text --><pre data-reactid="115"><code class="language-javascript" data-reactid="116">var liStyle = {
    fontWeight: &quot;normal&quot;
};
if (this.state.selectedMove === move) {
    liStyle[&quot;fontWeight&quot;] = &quot;bold&quot;;
}
return (
    &lt;li key={move}&gt;
      &lt;a href=&quot;#&quot; style={liStyle} onClick={() =&gt; this.jumpTo(move)}&gt;
        {desc}
      &lt;/a&gt;
    &lt;/li&gt;
);
</code></pre><!-- react-text: 117 -->
<!-- /react-text --><h2 id="how-i-did-a-nested-loop-in-jsx" data-reactid="118"><a href="#how-i-did-a-nested-loop-in-jsx" class="phenomic-HeadingAnchor" data-reactid="119">#</a><!-- react-text: 120 -->How I did a nested loop in jsx<!-- /react-text --></h2><!-- react-text: 121 -->
<!-- /react-text --><pre data-reactid="122"><code class="language-javascript" data-reactid="123">{Array.apply(null, Array(3)).map(function(item, i) {
  return (
    &lt;div className=&quot;board-row&quot;&gt;
      {Array.apply(null, Array(3)).map(function(item, j) {
        return this.renderSquare(i * 3 + j);
      }, this)}
    &lt;/div&gt;
  );
}, this)}
</code></pre><!-- react-text: 124 -->
<!-- /react-text --><h2 id="how-i-highlighted-the-winning-moves" data-reactid="125"><a href="#how-i-highlighted-the-winning-moves" class="phenomic-HeadingAnchor" data-reactid="126">#</a><!-- react-text: 127 -->How I highlighted the winning moves<!-- /react-text --></h2><!-- react-text: 128 -->
<!-- /react-text --><ol data-reactid="129"><!-- react-text: 130 -->
<!-- /react-text --><li data-reactid="131"><!-- react-text: 132 -->
<!-- /react-text --><p data-reactid="133"><!-- react-text: 134 -->Had <!-- /react-text --><code data-reactid="135">calculateWinner()</code><!-- react-text: 136 --> function return the value <!-- /react-text --><code data-reactid="137">square[a]</code><!-- react-text: 138 --> for each winning move as well as the index of the winning squares <!-- /react-text --><code data-reactid="139">lines[i]</code><!-- react-text: 140 -->.<!-- /react-text --></p><!-- react-text: 141 -->
<!-- /react-text --></li><!-- react-text: 142 -->
<!-- /react-text --><li data-reactid="143"><!-- react-text: 144 -->
<!-- /react-text --><p data-reactid="145"><!-- react-text: 146 -->Added props to keep track of which squares were winning moves from <!-- /react-text --><code data-reactid="147">calculateWinner</code><!-- react-text: 148 -->. Passed them to the board constructor which then passed those props to each square.<!-- /react-text --></p><!-- react-text: 149 -->
<!-- /react-text --></li><!-- react-text: 150 -->
<!-- /react-text --><li data-reactid="151"><!-- react-text: 152 -->
<!-- /react-text --><p data-reactid="153">Conditionally set the style of each square based on the props of each square being a winner or not.
My square component now looks like this:</p><!-- react-text: 154 -->
<!-- /react-text --></li><!-- react-text: 155 -->
<!-- /react-text --></ol><!-- react-text: 156 -->
<!-- /react-text --><pre data-reactid="157"><code class="language-javascript" data-reactid="158">function Square(props) {
  let myStyle;
  if (props.isWinner &amp;&amp; props.isWinner.includes(props.squareNum)) {
    myStyle = {
      color: &quot;#00d8ff&quot;
    };
  } else {
    myStyle = { color: &quot;black&quot; };
  }
  return (
    &lt;button className=&quot;square&quot; onClick={props.onClick} style={myStyle}&gt;
      {props.value}
    &lt;/button&gt;
  );
}
</code></pre></div></article></div></div><footer data-reactid="159"><div class="footer" data-reactid="160"><div data-reactid="161"><!-- react-text: 162 -->Scott LaForest © <!-- /react-text --><!-- react-text: 163 -->2017<!-- /react-text --></div><div data-reactid="164"><!-- react-text: 165 -->Created with ❤ using  <!-- /react-text --><a href="https://phenomic.io/" style="color:inherit;" data-reactid="166">Phenomic</a></div><div data-reactid="167"><!-- react-text: 168 -->Check out the source code  <!-- /react-text --><a href="https://github.com/scottyla19/phenomic-portfolio" style="color:inherit;" data-reactid="169"><i class="fa fa-github" data-reactid="170"></i></a></div></div></footer></div></div><script id="PhenomicHydration" type="text/json">{"collection=posts&id=2017-06-28":{"status":"idle","node":{"date":"2017-01-01","title":"React-Tac-Toe Notes","desc":"Notes from creating the react tic-tac-toe example from the Facebook tutorial. Includes controlled components, immutability, and how I added the optional upgrades listed at the bottom of the tutorial.","tags":"React","author":"Scott LaForest","posted":"06/28/17","body":{"c":[{"c":[{"c":"#","p":{"href":"#react-tac-toe-notes","className":"phenomic-HeadingAnchor"},"t":"a"},"React-Tac-Toe Notes"],"p":{"id":"react-tac-toe-notes"},"t":"h1"},"\n",{"c":[{"c":"#","p":{"href":"#moving-state-upwards","className":"phenomic-HeadingAnchor"},"t":"a"},"Moving State Upwards"],"p":{"id":"moving-state-upwards"},"t":"h2"},"\n",{"c":["It is best to aggregate data from multiple children in the parent. For example move the data and logic from the square => board => game component. The parent can then pass the state back down via props. This keeps the state consistent throughout the components.\n.\nSquare no longer keeps its own state; it receives its value from its parent Board and informs its parent when it's clicked. We call components like this ",{"c":"controlled components","t":"strong"},"."],"t":"p"},"\n",{"c":[{"c":"#","p":{"href":"#why-immutability-is-important","className":"phenomic-HeadingAnchor"},"t":"a"},"Why Immutability Is Important"],"p":{"id":"why-immutability-is-important"},"t":"h2"},"\n",{"c":"In the previous code example, we suggest using the .slice() operator to copy the squares array prior to making changes and to prevent mutating the existing array. Let's talk about what this means and why it is an important concept to learn.","t":"p"},"\n",{"c":"There are generally two ways for changing data. The first method is to mutate the data by directly changing the values of a variable. The second method is to replace the data with a new copy of the object that also includes desired changes.","t":"p"},"\n",{"c":"Data change with mutation","t":"p"},"\n",{"c":{"c":"var player = {score: 1, name: 'Jeff'};\nplayer.score = 2;\n// Now player is {score: 2, name: 'Jeff'}\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n",{"c":"Data change without mutation","t":"p"},"\n",{"c":{"c":"var player = {score: 1, name: 'Jeff'};\n\nvar newPlayer = Object.assign({}, player, {score: 2});\n// Now player is unchanged, but newPlayer is {score: 2, name: 'Jeff'}\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n",{"c":"The end result is the same but by not mutating (or changing the underlying data) directly we now have an added benefit that can help us increase component and overall application performance.","t":"p"},"\n",{"c":[{"c":"Easier Undo/Redo and Time Travel","t":"strong"},"\nImmutability also makes some complex features much easier to implement. Avoiding data mutations lets us keep a reference to older versions of the data, and switch between them if we need to."],"t":"p"},"\n",{"c":[{"c":"Tracking Changes","t":"strong"},"\nDetermining if a mutated object has changed is complex because changes are made directly to the object. This then requires comparing the current object to a previous copy, traversing the entire object tree, and comparing each variable and value. This process can become increasingly complex."],"t":"p"},"\n",{"c":"Determining how an immutable object has changed is considerably easier. If the object being referenced is different from before, then the object has changed. That's it.","t":"p"},"\n",{"c":[{"c":"Determining When to Re-render in React","t":"strong"},"\nThe biggest benefit of immutability in React comes when you build simple pure components. Since immutable data can more easily determine if changes have been made it also helps to determine when a component requires being re-rendered."],"t":"p"},"\n",{"c":["We've removed the constructor, and in fact, React supports a simpler syntax called ",{"c":"functional components for component types like Square that only consist of a render method","t":"strong"},"."],"t":"p"},"\n",{"c":[{"c":"#","p":{"href":"#how-i-bold-ed-the-currently-selected-move","className":"phenomic-HeadingAnchor"},"t":"a"},"How I ",{"c":"bold","t":"strong"}," ed the currently selected move"],"p":{"id":"how-i-bold-ed-the-currently-selected-move"},"t":"h2"},"\n",{"c":["\n",{"c":["Added a ",{"c":"selectedMove","t":"code"}," property in ",{"c":"this.state","t":"code"}," in the constructor"],"t":"li"},"\n",{"c":["Added ",{"c":"selectedMove: history.length","t":"code"}," in the ",{"c":"handleClick()","t":"code"}," function to make sure when a new move is added it becomes bold"],"t":"li"},"\n",{"c":["added the following line in the ",{"c":"this.setState({})","t":"code"},"call in the  ",{"c":"jumpTo(step)","t":"code"}," function ",{"c":"selectedMove : step","t":"code"},";"],"t":"li"},"\n",{"c":["changed the game ",{"c":"render()","t":"code"}," function to include"],"t":"li"},"\n"],"t":"ol"},"\n",{"c":{"c":"var liStyle = {\n    fontWeight: \"normal\"\n};\nif (this.state.selectedMove === move) {\n    liStyle[\"fontWeight\"] = \"bold\";\n}\nreturn (\n    <li key={move}>\n      <a href=\"#\" style={liStyle} onClick={() => this.jumpTo(move)}>\n        {desc}\n      </a>\n    </li>\n);\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n",{"c":[{"c":"#","p":{"href":"#how-i-did-a-nested-loop-in-jsx","className":"phenomic-HeadingAnchor"},"t":"a"},"How I did a nested loop in jsx"],"p":{"id":"how-i-did-a-nested-loop-in-jsx"},"t":"h2"},"\n",{"c":{"c":"{Array.apply(null, Array(3)).map(function(item, i) {\n  return (\n    <div className=\"board-row\">\n      {Array.apply(null, Array(3)).map(function(item, j) {\n        return this.renderSquare(i * 3 + j);\n      }, this)}\n    </div>\n  );\n}, this)}\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n",{"c":[{"c":"#","p":{"href":"#how-i-highlighted-the-winning-moves","className":"phenomic-HeadingAnchor"},"t":"a"},"How I highlighted the winning moves"],"p":{"id":"how-i-highlighted-the-winning-moves"},"t":"h2"},"\n",{"c":["\n",{"c":["\n",{"c":["Had ",{"c":"calculateWinner()","t":"code"}," function return the value ",{"c":"square[a]","t":"code"}," for each winning move as well as the index of the winning squares ",{"c":"lines[i]","t":"code"},"."],"t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":["Added props to keep track of which squares were winning moves from ",{"c":"calculateWinner","t":"code"},". Passed them to the board constructor which then passed those props to each square."],"t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":"Conditionally set the style of each square based on the props of each square being a winner or not.\nMy square component now looks like this:","t":"p"},"\n"],"t":"li"},"\n"],"t":"ol"},"\n",{"c":{"c":"function Square(props) {\n  let myStyle;\n  if (props.isWinner && props.isWinner.includes(props.squareNum)) {\n    myStyle = {\n      color: \"#00d8ff\"\n    };\n  } else {\n    myStyle = { color: \"black\" };\n  }\n  return (\n    <button className=\"square\" onClick={props.onClick} style={myStyle}>\n      {props.value}\n    </button>\n  );\n}\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"}],"t":"div"}}}}</script><script src="/phenomic.main.js" async=""></script></body></html>