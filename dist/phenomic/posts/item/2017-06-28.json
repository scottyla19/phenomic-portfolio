{"date":"2017-01-01","title":"React-Tac-Toe Notes","desc":"Notes from creating the react tic-tac-toe example from the Facebook tutorial. Includes controlled components, immutability, and how I added the optional upgrades listed at the bottom of the tutorial.","tags":"React","author":"Scott LaForest","posted":"06/28/17","body":{"c":[{"c":[{"c":"#","p":{"href":"#react-tac-toe-notes","className":"phenomic-HeadingAnchor"},"t":"a"},"React-Tac-Toe Notes"],"p":{"id":"react-tac-toe-notes"},"t":"h1"},"\n",{"c":[{"c":"#","p":{"href":"#moving-state-upwards","className":"phenomic-HeadingAnchor"},"t":"a"},"Moving State Upwards"],"p":{"id":"moving-state-upwards"},"t":"h2"},"\n",{"c":["It is best to aggregate data from multiple children in the parent. For example move the data and logic from the square => board => game component. The parent can then pass the state back down via props. This keeps the state consistent throughout the components.\n.\nSquare no longer keeps its own state; it receives its value from its parent Board and informs its parent when it's clicked. We call components like this ",{"c":"controlled components","t":"strong"},"."],"t":"p"},"\n",{"c":[{"c":"#","p":{"href":"#why-immutability-is-important","className":"phenomic-HeadingAnchor"},"t":"a"},"Why Immutability Is Important"],"p":{"id":"why-immutability-is-important"},"t":"h2"},"\n",{"c":"In the previous code example, we suggest using the .slice() operator to copy the squares array prior to making changes and to prevent mutating the existing array. Let's talk about what this means and why it is an important concept to learn.","t":"p"},"\n",{"c":"There are generally two ways for changing data. The first method is to mutate the data by directly changing the values of a variable. The second method is to replace the data with a new copy of the object that also includes desired changes.","t":"p"},"\n",{"c":"Data change with mutation","t":"p"},"\n",{"c":{"c":"var player = {score: 1, name: 'Jeff'};\nplayer.score = 2;\n// Now player is {score: 2, name: 'Jeff'}\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n",{"c":"Data change without mutation","t":"p"},"\n",{"c":{"c":"var player = {score: 1, name: 'Jeff'};\n\nvar newPlayer = Object.assign({}, player, {score: 2});\n// Now player is unchanged, but newPlayer is {score: 2, name: 'Jeff'}\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n",{"c":"The end result is the same but by not mutating (or changing the underlying data) directly we now have an added benefit that can help us increase component and overall application performance.","t":"p"},"\n",{"c":[{"c":"Easier Undo/Redo and Time Travel","t":"strong"},"\nImmutability also makes some complex features much easier to implement. Avoiding data mutations lets us keep a reference to older versions of the data, and switch between them if we need to."],"t":"p"},"\n",{"c":[{"c":"Tracking Changes","t":"strong"},"\nDetermining if a mutated object has changed is complex because changes are made directly to the object. This then requires comparing the current object to a previous copy, traversing the entire object tree, and comparing each variable and value. This process can become increasingly complex."],"t":"p"},"\n",{"c":"Determining how an immutable object has changed is considerably easier. If the object being referenced is different from before, then the object has changed. That's it.","t":"p"},"\n",{"c":[{"c":"Determining When to Re-render in React","t":"strong"},"\nThe biggest benefit of immutability in React comes when you build simple pure components. Since immutable data can more easily determine if changes have been made it also helps to determine when a component requires being re-rendered."],"t":"p"},"\n",{"c":["We've removed the constructor, and in fact, React supports a simpler syntax called ",{"c":"functional components for component types like Square that only consist of a render method","t":"strong"},"."],"t":"p"},"\n",{"c":[{"c":"#","p":{"href":"#how-i-bold-ed-the-currently-selected-move","className":"phenomic-HeadingAnchor"},"t":"a"},"How I ",{"c":"bold","t":"strong"}," ed the currently selected move"],"p":{"id":"how-i-bold-ed-the-currently-selected-move"},"t":"h2"},"\n",{"c":["\n",{"c":["Added a ",{"c":"selectedMove","t":"code"}," property in ",{"c":"this.state","t":"code"}," in the constructor"],"t":"li"},"\n",{"c":["Added ",{"c":"selectedMove: history.length","t":"code"}," in the ",{"c":"handleClick()","t":"code"}," function to make sure when a new move is added it becomes bold"],"t":"li"},"\n",{"c":["added the following line in the ",{"c":"this.setState({})","t":"code"},"call in the  ",{"c":"jumpTo(step)","t":"code"}," function ",{"c":"selectedMove : step","t":"code"},";"],"t":"li"},"\n",{"c":["changed the game ",{"c":"render()","t":"code"}," function to include"],"t":"li"},"\n"],"t":"ol"},"\n",{"c":{"c":"var liStyle = {\n    fontWeight: \"normal\"\n};\nif (this.state.selectedMove === move) {\n    liStyle[\"fontWeight\"] = \"bold\";\n}\nreturn (\n    <li key={move}>\n      <a href=\"#\" style={liStyle} onClick={() => this.jumpTo(move)}>\n        {desc}\n      </a>\n    </li>\n);\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n",{"c":[{"c":"#","p":{"href":"#how-i-did-a-nested-loop-in-jsx","className":"phenomic-HeadingAnchor"},"t":"a"},"How I did a nested loop in jsx"],"p":{"id":"how-i-did-a-nested-loop-in-jsx"},"t":"h2"},"\n",{"c":{"c":"{Array.apply(null, Array(3)).map(function(item, i) {\n  return (\n    <div className=\"board-row\">\n      {Array.apply(null, Array(3)).map(function(item, j) {\n        return this.renderSquare(i * 3 + j);\n      }, this)}\n    </div>\n  );\n}, this)}\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n",{"c":[{"c":"#","p":{"href":"#how-i-highlighted-the-winning-moves","className":"phenomic-HeadingAnchor"},"t":"a"},"How I highlighted the winning moves"],"p":{"id":"how-i-highlighted-the-winning-moves"},"t":"h2"},"\n",{"c":["\n",{"c":["\n",{"c":["Had ",{"c":"calculateWinner()","t":"code"}," function return the value ",{"c":"square[a]","t":"code"}," for each winning move as well as the index of the winning squares ",{"c":"lines[i]","t":"code"},"."],"t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":["Added props to keep track of which squares were winning moves from ",{"c":"calculateWinner","t":"code"},". Passed them to the board constructor which then passed those props to each square."],"t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":"Conditionally set the style of each square based on the props of each square being a winner or not.\nMy square component now looks like this:","t":"p"},"\n"],"t":"li"},"\n"],"t":"ol"},"\n",{"c":{"c":"function Square(props) {\n  let myStyle;\n  if (props.isWinner && props.isWinner.includes(props.squareNum)) {\n    myStyle = {\n      color: \"#00d8ff\"\n    };\n  } else {\n    myStyle = { color: \"black\" };\n  }\n  return (\n    <button className=\"square\" onClick={props.onClick} style={myStyle}>\n      {props.value}\n    </button>\n  );\n}\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"}],"t":"div"}}