{"date":"2017-01-01","title":"PWA Service Worker Notes","desc":"Notes from the Google PWA Service Worker CodeLab. Includes install, activate, and SW scope.","tags":"PWA","author":"Scott LaForest","posted":"05/09/17","body":{"c":[{"c":[{"c":"#","p":{"href":"#notes","className":"phenomic-HeadingAnchor"},"t":"a"},"Notes"],"p":{"id":"notes"},"t":"h1"},"\n",{"c":["\n",{"c":"Service workers must be registered.","t":"li"},"\n",{"c":["Always start by checking if the browser supports service workers. The service\nworker is exposed on the browser's ",{"c":"Navigator","p":{"href":"https://developer.mozilla.org/en-US/docs/Web/API/Navigator"},"t":"a"}," i.e. ",{"c":"window.navigator.serviceWorker","t":"code"}],"t":"li"},"\n"],"t":"ul"},"\n",{"c":[{"c":"#","p":{"href":"#sw-life-cycle","className":"phenomic-HeadingAnchor"},"t":"a"},"SW Life Cycle"],"p":{"id":"sw-life-cycle"},"t":"h1"},"\n",{"c":["\n",{"c":["The service worker emits an ",{"c":"install","t":"code"}," event at the end of registration (this is a good place for caching static assets). SW emits an  ",{"c":"activate","t":"code"}," event when it takes control of the page (is often used to update caches)."],"t":"li"},"\n"],"t":"ul"},"\n",{"c":{"c":"  self.addEventListener('install', function(event) {\n    console.log('Service worker installing...');\n    });\n\n  self.addEventListener('activate', function(event) {\n    console.log('Service worker activating...');\n  });\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n",{"c":["\n",{"c":["\n",{"c":"fetch events are received for every HTTP request (we could also create and return our own custom response with arbitrary resources).","t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":"Why didn't a failed response activate the catch block? This is an important note for fetch and promisesâ€”bad responses (like 404s) still resolve! A fetch promise only rejects if the request was unable to complete, so you must always check the validity of the response.","t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":"Getting headers involves getting a headers object var myHeaders = response.headers then calling the get funciotn on the object. myHeaders.get(name)","t":"p"},"\n"],"t":"li"},"\n"],"t":"ul"},"\n",{"c":{"c":"self.addEventListener('fetch', function(event) {\n    console.log('Fetching:', event.request.url);\n});\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n",{"c":[{"c":"#","p":{"href":"#sw-scope","className":"phenomic-HeadingAnchor"},"t":"a"},"SW Scope"],"p":{"id":"sw-scope"},"t":"h1"},"\n",{"c":["\n",{"c":["The promise returned by ",{"c":"register()","t":"code"}," resolves to the registration object, which contains the service worker's scope."],"t":"li"},"\n"],"t":"ul"},"\n",{"c":{"c":"The default scope is the path to the service worker file, and extends to all lower directories. So a service worker in the root directory of an app controls requests from all files in the app.","t":"strong"},"t":"p"},"\n",{"c":["\n",{"c":["\n",{"c":["Notice if ",{"c":"service-worker.js","t":"code"}," is in a subdirectory (/below) then the service worker only controls requests for the requests in that subdirectory. The service worker's default scope is the path to the service worker file. Since the service worker file is now in app/below/, that is its scope. The console is now only logging fetch events for another.html, another.css, and another.js, because these are the only resources within the service worker's scope (app/below/)."],"t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":"Can set an arbitrary scope using the options in serviceWorker.register().","t":"p"},"\n"],"t":"li"},"\n"],"t":"ul"},"\n",{"c":{"c":"navigator.serviceWorker.register('service-worker.js',\n{scope: './below'})\n.then(function(registration) {\n    console.log('Registered at scope:', registration.scope);\n})```\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"}],"t":"div"}}