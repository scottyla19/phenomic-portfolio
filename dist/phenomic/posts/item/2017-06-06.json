{"date":"2017-01-01","title":"You Don't Know JS Part 5","desc":"Notes on the fifth day of reading through You Don't Know JS. Includes more on closure, more on modules, and a lot on this.","tags":"YDKJS","author":"Scott LaForest","posted":"06/06/17","body":{"c":[{"c":["All examples and notes are taken from the excellent and free to ",{"c":"read (online)","p":{"href":"https://github.com/getify/You-Dont-Know-JS"},"t":"a"}," series of books titled ",{"c":"You Don't Know JS","t":"em"}," by Kyle Simpson."],"t":"p"},"\n",{"c":[{"c":"#","p":{"href":"#6617","className":"phenomic-HeadingAnchor"},"t":"a"},"6/6/17"],"p":{"id":"6617"},"t":"h2"},"\n",{"c":[{"c":"#","p":{"href":"#more-on-closure","className":"phenomic-HeadingAnchor"},"t":"a"},"More on Closure"],"p":{"id":"more-on-closure"},"t":"h3"},"\n",{"c":"Closure is when a function is able to remember and access its lexical scope even when that function is executing outside its lexical scope.","t":"p"},"\n",{"c":[{"c":"#","p":{"href":"#more-on-modules","className":"phenomic-HeadingAnchor"},"t":"a"},"More on Modules"],"p":{"id":"more-on-modules"},"t":"h3"},"\n",{"c":["Below is an example of a \"Revealing Module\". Requirements for modules:\n1. It is just a function and must be invoked for every instance. ",{"c":"There must be an outer enclosing function, and it must be invoked at least once (each time creates a new module instance).","t":"em"},"\n2. Returns an object ",{"c":"{key:value,...}","t":"code"}," with access to the 'public' functions but not the inner 'private' variables. Performs like a public API. ",{"c":"The enclosing function must return back at least one inner function, so that this inner function has closure over the private scope, and can access and/or modify that private state.","t":"em"}],"t":"p"},"\n",{"c":{"c":"    var something = \"cool\";\n    var another = [1, 2, 3];\n\n    function doSomething() {\n        console.log( something );\n    }\n\n    function doAnother() {\n        console.log( another.join( \" ! \" ) );\n    }\n\n    return {\n        doSomething: doSomething,\n        doAnother: doAnother\n    };\n}\n\nvar foo = CoolModule();\n\nfoo.doSomething(); // cool\nfoo.doAnother(); // 1 ! 2 ! 3\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n",{"c":"Turn the function into an IIFE to create singleton objects.","t":"p"},"\n",{"c":{"c":"var foo = (function CoolModule() {\n    var something = \"cool\";\n    var another = [1, 2, 3];\n\n    function doSomething() {\n        console.log( something );\n    }\n\n    function doAnother() {\n        console.log( another.join( \" ! \" ) );\n    }\n\n    return {\n        doSomething: doSomething,\n        doAnother: doAnother\n    };\n})();\n\nfoo.doSomething(); // cool\nfoo.doAnother(); // 1 ! 2 ! 3\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n",{"c":[{"c":"#","p":{"href":"#this","className":"phenomic-HeadingAnchor"},"t":"a"},"this"],"p":{"id":"this"},"t":"h3"},"\n",{"c":[" ",{"c":[{"c":"this","t":"code"}," is neither a reference to the function itself, nor is it a reference to the function's lexical scope"],"t":"strong"},"."],"t":"p"},"\n",{"c":[{"c":"this","t":"code"}," is actually a binding that is made when a function is invoked, and what it ",{"c":"references is determined entirely by the call-site where the function is called.","t":"strong"}],"t":"p"},"\n",{"c":{"c":"function baz() {\n    // call-stack is: `baz`\n    // so, our call-site is in the global scope\n\n    console.log( \"baz\" );\n    bar(); // <-- call-site for `bar`\n}\n\nfunction bar() {\n    // call-stack is: `baz` -> `bar`\n    // so, our call-site is in `baz`\n\n    console.log( \"bar\" );\n    foo(); // <-- call-site for `foo`\n}\n\nfunction foo() {\n    // call-stack is: `baz` -> `bar` -> `foo`\n    // so, our call-site is in `bar`\n\n    console.log( \"foo\" );\n}\n\nbaz(); // <-- call-site for `baz`\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n",{"c":"Take care when analyzing code to find the actual call-site (from the call-stack), because it's the only thing that matters for this binding.","t":"p"},"\n",{"c":[{"c":"#","p":{"href":"#this-binding-rules","className":"phenomic-HeadingAnchor"},"t":"a"},"this Binding rules"],"p":{"id":"this-binding-rules"},"t":"h3"},"\n",{"c":["\n",{"c":["\n",{"c":"Default Binding: The default rule when all others do not apply.","t":"p"},"\n",{"c":{"c":"function foo() {\n            console.log( this.a );\n}\n\nvar a = 2;\n\nfoo(); // 2\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n",{"c":["Notice when ",{"c":"foo()","t":"code"}," is called, ",{"c":"this.a","t":"code"}," resolves to our global variable a. Why? Because in this case, the default binding for ",{"c":"this","t":"code"}," applies to the function call, and so points ",{"c":"this","t":"code"}," at the global object."],"t":"p"},"\n",{"c":["If ",{"c":"strict","t":"code"}," mode is in effect, the global object is not eligible for the default binding, so the ",{"c":"this","t":"code"}," is instead set to undefined."],"t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":"Implicit Binding (Left of the dot): Does the call-site have a context object, also referred to as an owning or containing object.","t":"p"},"\n",{"c":{"c":"function foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2,\n    foo: foo\n};\n\nobj.foo(); // 2\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n",{"c":["The call-site uses the ",{"c":"obj","t":"code"}," context to reference the function, so you could say that the ",{"c":"obj","t":"code"}," object \"owns\" or \"contains\" the function reference at the time the function is called."],"t":"p"},"\n",{"c":["Because ",{"c":"obj","t":"code"}," is the ",{"c":"this","t":"code"}," for the ",{"c":"foo()","t":"code"}," call, ",{"c":"this.a","t":"code"}," is synonymous with obj.a."],"t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":["Explicit Binding: Directly stating what the ",{"c":"this","t":"code"}," should be using either ",{"c":"call()","t":"code"},", ",{"c":"apply()","t":"code"},", or even ",{"c":"bind()","t":"code"},"."],"t":"p"},"\n",{"c":[{"c":"bind()","t":"code"}," returns a function which will act like the original function but with ",{"c":"this","t":"code"}," predefined. It is usually used when you want to pass a function to an event handler or other async callback."],"t":"p"},"\n",{"c":[{"c":"call()","t":"code"}," and ",{"c":"apply()","t":"code"}," will call a function immediately letting you specify both the value of ",{"c":"this","t":"code"}," and any arguments the function will receive. Difference between ",{"c":"call()","t":"code"}," and ",{"c":"apply()","t":"code"}," is both accept additional parameters but ",{"c":"call()","t":"code"}," must specify each additional parameter separated by a comma. Whereas ",{"c":"apply()","t":"code"}," can pass in an array of additional parameters."],"t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":["New Binding: Using the ",{"c":"new","t":"code"}," operator when creating a new variable. This does four things:"],"t":"p"},"\n",{"c":["\n",{"c":"Creates a brand new object (aka, constructed) out of thin air","t":"li"},"\n",{"c":["The newly constructed object is [","[","Prototype","]","]-linked"],"t":"li"},"\n",{"c":["The newly constructed object is set as the ",{"c":"this","t":"code"}," binding for that function call"],"t":"li"},"\n",{"c":"Unless the function returns its own alternate object, the new-invoked function call will automatically return the newly constructed object.","t":"li"},"\n"],"t":"ol"},"\n"],"t":"li"},"\n"],"t":"ol"},"\n",{"c":{"c":"    function foo(a) {\n        this.a = a;\n    }\n\n    var bar = new foo( 2 );\n    console.log( bar.a ); // 2\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n",{"c":[{"c":"#","p":{"href":"#determining-this","className":"phenomic-HeadingAnchor"},"t":"a"},"Determining this"],"p":{"id":"determining-this"},"t":"h3"},"\n",{"c":["\n",{"c":["\n",{"c":"Is the function called with new (new binding)? If so, this is the newly constructed object.","t":"p"},"\n",{"c":{"c":"var bar = new foo()","t":"code"},"t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":["Is the function called with ",{"c":"call","t":"code"}," or ",{"c":"apply","t":"code"}," (explicit binding), even hidden inside a ",{"c":"bind","t":"code"}," hard binding? If so, ",{"c":"this","t":"code"}," is the explicitly specified object."],"t":"p"},"\n",{"c":{"c":"var bar = foo.call( obj2 )","t":"code"},"t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":["Is the function called with a context (implicit binding), otherwise known as an owning or containing object? If so, ",{"c":"this","t":"code"}," is that context object."],"t":"p"},"\n",{"c":{"c":"var bar = obj1.foo()","t":"code"},"t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":["Otherwise, default the ",{"c":"this","t":"code"}," (default binding). If in ",{"c":"strict mode","t":"code"},", pick undefined, otherwise pick the global object."],"t":"p"},"\n",{"c":{"c":"var bar = foo()","t":"code"},"t":"p"},"\n"],"t":"li"},"\n"],"t":"ol"}],"t":"div"}}