{"date":"2017-01-01","title":"You Don't Know JS Part 1","desc":"Notes on the first day of reading through You Don't Know JS. Includes coercion, scope, and variables.","tags":"YDKJS","author":"Scott LaForest","posted":"05/31/17","body":{"c":[{"c":["All examples and notes are taken from the excellent and free to ",{"c":"read (online)","p":{"href":"https://github.com/getify/You-Dont-Know-JS"},"t":"a"}," series of books titled ",{"c":"You Don't Know JS","t":"em"}," by Kyle Simpson."],"t":"p"},"\n",{"c":[{"c":"#","p":{"href":"#53117","className":"phenomic-HeadingAnchor"},"t":"a"},"5/31/17"],"p":{"id":"53117"},"t":"h2"},"\n",{"c":["  ",{"c":"Javascript coercion","t":"strong"}," and the difference between implicit and explicit coercion when converting or comparing values. Loose equals (",{"c":"==","t":"code"},") implicitly coerces a string value to a number value ",{"c":"'99.99' == 99.9","t":"code"},". While strict equals (",{"c":"===","t":"code"},") does not convert types, so types must be the same and equal in strict equals."],"t":"p"},"\n",{"c":["  ",{"c":"Comments","t":"strong"}],"t":"p"},"\n",{"c":["\n",{"c":["\n",{"c":"Code without comments is suboptimal.","t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":"Too many comments (one per line, for example) is probably a sign of poorly written code.","t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":["Comments should explain ",{"c":"why","t":"em"},", not what. They can optionally explain how if that's particularly confusing"],"t":"p"},"\n",{"c":[{"c":"#","p":{"href":"#scope","className":"phenomic-HeadingAnchor"},"t":"a"},"Scope"],"p":{"id":"scope"},"t":"h3"},"\n",{"c":"In JavaScript, each function gets its own scope. Scope is basically a collection of variables as well as the rules for how those variables are accessed by name. Only code inside that function can access that function's scoped variables.","t":"p"},"\n",{"c":" If one scope is nested inside another, code inside the innermost scope can access variables from either scope.","t":"p"},"\n",{"c":[{"c":"#","p":{"href":"#variables-and-types","className":"phenomic-HeadingAnchor"},"t":"a"},"Variables and Types"],"p":{"id":"variables-and-types"},"t":"h3"},"\n",{"c":" The best and most natural approach is to use arrays for numerically positioned values and use objects for named properties.","t":"p"},"\n",{"c":" The specific list of \"falsy\" values in JavaScript is as follows:","t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":"\"\" (empty string)","t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":"0, -0, NaN (invalid number)","t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":"null, undefined","t":"p"},"\n"],"t":"li"},"\n",{"c":["\n",{"c":"false","t":"p"},"\n",{"c":[{"c":"WTF","t":"strong"},"\nFor example, arrays are by default coerced to strings by simply joining all the values with commas (,) in between. You might think that two arrays with the same contents would be == equal, but they're not:"],"t":"p"},"\n",{"c":{"c":"var a = [1,2,3];\nvar b = [1,2,3];\nvar c = \"1,2,3\";\n\na == c;     // true\nb == c;     // true\na == b;     // false\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n"],"t":"li"},"\n"],"t":"ul"}],"t":"div"}}