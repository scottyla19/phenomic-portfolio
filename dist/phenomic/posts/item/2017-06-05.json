{"date":"2017-01-01","title":"You Don't Know JS Part 4","desc":"Notes on the fourth day of reading through You Don't Know JS. Includes strict mode, scope, and let.","tags":"YDKJS","author":"Scott LaForest","posted":"06/05/17","body":{"c":[{"c":["All examples and notes are taken from the excellent and free to ",{"c":"read (online)","p":{"href":"https://github.com/getify/You-Dont-Know-JS"},"t":"a"}," series of books titled ",{"c":"You Don't Know JS","t":"em"}," by Kyle Simpson."],"t":"p"},"\n",{"c":[{"c":"#","p":{"href":"#6517","className":"phenomic-HeadingAnchor"},"t":"a"},"6/5/17"],"p":{"id":"6517"},"t":"h2"},"\n",{"c":[{"c":"#","p":{"href":"#scope","className":"phenomic-HeadingAnchor"},"t":"a"},"Scope"],"p":{"id":"scope"},"t":"h3"},"\n",{"c":[{"c":"use strict mode","t":"em"}," it seems safer ",{"c":"use strict","t":"code"}," it avoids the auto creation of a new variable in the global scope."],"t":"p"},"\n",{"c":[{"c":"ReferenceError","t":"code"}," is Scope resolution-failure related, whereas ",{"c":"TypeError","t":"code"}," implies that Scope resolution was successful, but that there was an illegal/impossible action attempted against the result."],"t":"p"},"\n",{"c":{"c":"Scope look-up stops once it finds the first match.","t":"strong"},"t":"p"},"\n",{"c":{"c":"function foo(a) {\n    var b = 2;\n\n    // some code\n\n    function bar() {\n        // ...\n    }\n\n    // more code\n\n    var c = 3;\n}\n","p":{"className":"language-javascript"},"t":"code"},"t":"pre"},"\n",{"c":["Because ",{"c":"a","t":"code"},", ",{"c":"b","t":"code"},", ",{"c":"c","t":"code"},", and ",{"c":"bar","t":"code"}," all belong to the scope bubble of ",{"c":"foo(..)","t":"code"},", they are not accessible outside of ",{"c":"foo(..)","t":"code"},"."],"t":"p"},"\n",{"c":"However, all these identifiers (a, b, c, foo, and bar) are accessible inside of foo(..), and indeed also available inside of bar(..) (assuming there are no shadow identifier declarations inside bar(..)).","t":"p"},"\n",{"c":[{"c":"Do not use anonymous functions","t":"strong"}," i.e. ",{"c":"function(){...}","t":"code"}," instead use:"],"t":"p"},"\n",{"c":[{"c":"Inline function expressions","t":"strong"}," ",{"c":"function name(){...}","t":"code"},"are powerful and useful -- the question of anonymous vs. named doesn't detract from that. Providing a name for your function expression quite effectively addresses all these draw-backs, but has no tangible downsides. The best practice is to always name your function expressions:"],"t":"p"},"\n",{"c":[{"c":"#","p":{"href":"#let","className":"phenomic-HeadingAnchor"},"t":"a"},"let"],"p":{"id":"let"},"t":"h3"},"\n",{"c":"i.e. block scoping like most other languages.","t":"p"},"\n",{"c":["The ",{"c":"let","t":"code"}," keyword attaches the variable declaration to the scope of whatever block (commonly a { .. } pair) it's contained in. In other words, ",{"c":"let","t":"code"}," implicitly hijacks any block's scope for its variable declaration."],"t":"p"}],"t":"div"}}